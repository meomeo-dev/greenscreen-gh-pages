<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç»¿å¹•ç”Ÿæˆå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 760px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #00B140, #00D4AA);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .section-subtitle {
            margin: 12px 0 8px;
            font-size: 14px;
            color: #555;
            font-weight: 600;
        }

        .aspect-ratio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .aspect-btn {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: 500;
        }

        .aspect-btn:hover {
            background: #e9ecef;
            transform: translateY(-2px);
        }

        .aspect-btn.active {
            background: #00B140;
            color: white;
            border-color: #00B140;
        }

        .orientation-group {
            margin-top: 6px;
        }

        .custom-input {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
        }

        .custom-input input {
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 16px;
        }

        .custom-input span {
            text-align: center;
            font-weight: bold;
            color: #666;
        }

        .generate-btn {
            background: linear-gradient(45deg, #00B140, #00D4AA);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin: 20px 0;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 177, 64, 0.3);
        }

        .result-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }

        .result-section.show {
            display: block;
        }

        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }

        #greenscreen-canvas {
            border: 2px solid #00B140;
            border-radius: 0;
            max-width: 100%;
            height: auto;
        }

        .download-btn,
        .copy-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            margin: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .download-btn:hover,
        .copy-btn:hover {
            background: #5a6268;
            transform: translateY(-1px);
        }

        .prompt-section {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .prompt-text {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            margin: 10px 0;
            border: 1px solid #e9ecef;
        }

        .copy-success {
            background: #28a745 !important;
        }

        .info-text {
            color: #666;
            font-size: 14px;
            margin-top: 10px;
            line-height: 1.5;
        }

        /* Layers panel */
        .ws-layers-panel {
            margin-top: 12px;
            background: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 6px;
        }
        .ws-layers-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-bottom: 1px solid #f1f3f5;
        }
        .ws-layers-header button {
            background:#6c757d;
            color:#fff;
            border:none;
            padding:6px 10px;
            border-radius:6px;
            cursor:pointer;
            font-weight:600;
        }
        .ws-layers-header button:hover {
            background:#5a6268;
        }
        .ws-layers-content {
            max-height: 180px;
            overflow-y: auto;
            padding: 6px;
        }
        .ws-layer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 8px;
            border: 1px solid #f1f3f5;
            border-radius: 6px;
            margin: 4px 0;
            cursor: pointer;
            user-select: none;
            background: #f8f9fa;
        }
        .ws-layer-item:hover {
            background: #eef2f3;
        }
        .ws-layer-item.selected {
            border-color: #00B140;
            background: #e6fff1;
        }
        .ws-layer-type {
            width: 22px;
            text-align: center;
        }
        .ws-layer-label {
            flex: 1;
            color: #333;
            font-weight: 600;
        }
        .ws-layer-handle {
            color: #666;
            font-size: 16px;
            cursor: grab;
        }
        .ws-layers-panel.collapsed .ws-layers-content {
            display: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¬ ç»¿å¹•ç”Ÿæˆå™¨(ç¦»çº¿ç‰ˆ, ä¸å­˜å‚¨ä»»ä½•æ•°æ®)</h1>
            <p>Generate green screen images with custom aspect ratios</p>
        </div>

        <div class="content">
            <div class="form-group">
                <label>é€‰æ‹©å®½é«˜æ¯” / Select Aspect Ratio:</label>
                <div class="section-subtitle">ç¤¾äº¤åª’ä½“ / Social Media</div>
                <div class="aspect-ratio-grid">
                    <div class="aspect-btn" data-ratio="1:1" data-label="instagram-square">1:1<br><small>Instagram
                            Square</small></div>
                    <div class="aspect-btn" data-ratio="4:5" data-label="instagram-portrait">4:5<br><small>Instagram
                            Portrait</small></div>
                    <div class="aspect-btn" data-ratio="9:16" data-label="story-reels-tiktok">
                        9:16<br><small>Story/Reels/TikTok</small></div>
                    <div class="aspect-btn" data-ratio="1.91:1" data-label="fb-twitter-landscape">
                        1.91:1<br><small>FB/Twitter Landscape</small></div>
                    <div class="aspect-btn" data-ratio="2:3" data-label="pinterest">2:3<br><small>Pinterest</small>
                    </div>
                    <div class="aspect-btn" data-ratio="3:4" data-label="x-portrait">3:4<br><small>X Portrait</small>
                    </div>
                </div>

                <div class="section-subtitle">è§†é¢‘åˆ›ä½œ / Video</div>
                <div class="aspect-ratio-grid">
                    <div class="aspect-btn" data-ratio="16:9" data-label="hd-youtube">16:9<br><small>HD/YouTube</small>
                    </div>
                    <div class="aspect-btn" data-ratio="4:3" data-label="classic">4:3<br><small>Classic</small></div>
                    <div class="aspect-btn" data-ratio="3:2" data-label="camera">3:2<br><small>Camera</small></div>
                    <div class="aspect-btn" data-ratio="2.39:1" data-label="cinemascope">
                        2.39:1<br><small>Cinemascope</small></div>
                    <div class="aspect-btn" data-ratio="1.85:1" data-label="academy-flat">1.85:1<br><small>Academy
                            Flat</small></div>
                    <div class="aspect-btn" data-ratio="17:9" data-label="dci">17:9<br><small>DCI</small></div>
                    <div class="aspect-btn" data-ratio="1.43:1" data-label="imax">1.43:1<br><small>IMAX</small></div>
                    <div class="aspect-btn" data-ratio="21:9" data-label="ultra-wide">21:9<br><small>Ultra-wide</small>
                    </div>
                </div>

                <div class="section-subtitle">æ˜¾ç¤ºè®¾å¤‡ (2020+) / Displays</div>
                <div class="aspect-ratio-grid">
                    <div class="aspect-btn" data-ratio="16:10" data-label="laptop-16-10">16:10<br><small>Apple MacBook,
                            Dell/Lenovo</small></div>
                    <div class="aspect-btn" data-ratio="3:2" data-label="laptop-3-2">3:2<br><small>Microsoft Surface,
                            Huawei MateBook</small></div>
                    <div class="aspect-btn" data-ratio="16:9" data-label="tv-16-9">16:9<br><small>TV:
                            Samsung/LG/Sony</small></div>
                    <div class="aspect-btn" data-ratio="21:9" data-label="lg-ultrawide">21:9<br><small>LG
                            UltraWide</small></div>
                    <div class="aspect-btn" data-ratio="32:9" data-label="samsung-super-ultrawide">
                        32:9<br><small>Samsung Super UltraWide</small></div>
                </div>

                <div class="section-subtitle">ç§»åŠ¨è®¾å¤‡ (2020+) / Mobile</div>
                <div class="aspect-ratio-grid">
                    <div class="aspect-btn" data-ratio="19.5:9" data-label="apple-iphone">19.5:9<br><small>Apple
                            iPhone</small></div>
                    <div class="aspect-btn" data-ratio="20:9" data-label="android-20-9">20:9<br><small>Google
                            Pixel</small></div>
                    <div class="aspect-btn" data-ratio="19:9" data-label="android-19-9">19:9<br><small>Android
                            (common)</small></div>
                    <div class="aspect-btn" data-ratio="2:1" data-label="mobile-2-1">2:1<br><small>Mobile Tall
                            (18:9)</small></div>
                </div>

                <div class="section-subtitle">æ–¹å‘ / Orientation</div>
                <div class="aspect-ratio-grid orientation-group"
                    style="grid-template-columns: repeat(2, minmax(120px, 1fr));">
                    <div class="aspect-btn orientation-btn" data-orientation="landscape">æ¨ªå‘<br><small>Landscape</small>
                    </div>
                    <div class="aspect-btn orientation-btn" data-orientation="portrait">çºµå‘<br><small>Portrait</small>
                    </div>
                </div>

                <div class="custom-input">
                    <input type="number" id="custom-width" placeholder="å®½åº¦" min="1" max="4000">
                    <span>:</span>
                    <input type="number" id="custom-height" placeholder="é«˜åº¦" min="1" max="4000">
                </div>
            </div>



            <div class="result-section" id="result-section">
                <h3>ğŸ“¸ ç”Ÿæˆç»“æœ / Generated Result</h3>
                <div class="canvas-container">
                    <canvas id="greenscreen-canvas"></canvas>
                </div>

                <div style="text-align: center;">
                    <button class="download-btn" onclick="downloadImage(1)">ğŸ’¾ ä¸‹è½½1å€å›¾ Download 1x</button>
                    <button class="download-btn" onclick="downloadImage(2)">ğŸ’¾ ä¸‹è½½2å€å›¾ Download 2x</button>
                    <button class="download-btn" onclick="downloadImage(3)">ğŸ’¾ ä¸‹è½½3å€å›¾ Download 3x</button>
                </div>

                <div class="prompt-section">
                    <h4>ğŸ“ AIæç¤ºè¯æ¨¡æ¿ (ç»¿å¹•ä¿®æ”¹) / AI Prompt Template</h4>
                    <div class="prompt-text" id="prompt-text"></div>
                    <button class="copy-btn" id="copy-btn1" onclick="copyPrompt()">
                        ğŸ“‹ å¤åˆ¶æç¤ºè¯ Copy Prompt
                    </button>
                </div>

                <div class="prompt-section">
                    <h4>ğŸ“ AIæç¤ºè¯æ¨¡æ¿(n åˆ 1) / AI Prompt Template</h4>
                    <div class="prompt-text" id="prompt-text2"></div>
                    <button class="copy-btn" id="copy-btn2" onclick="copyPrompt2()">
                        ğŸ“‹ å¤åˆ¶æç¤ºè¯ Copy Prompt
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentRatio = '16:9';
        let currentLabel = 'hd-youtube';
        let orientation = 'landscape';

        // é¢„è®¾å®½é«˜æ¯”é€‰æ‹©
        document.querySelectorAll('.aspect-btn').forEach(btn => {
            btn.addEventListener('click', function () {
                if (this.dataset.ratio) {
                    document.querySelectorAll('.aspect-btn[data-ratio]').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentRatio = this.dataset.ratio;
                    currentLabel = this.dataset.label || 'custom';

                    // æ¸…ç©ºè‡ªå®šä¹‰è¾“å…¥
                    document.getElementById('custom-width').value = '';
                    document.getElementById('custom-height').value = '';

                    // é€‰æ‹©é¢„è®¾å³è‡ªåŠ¨æ¸²æŸ“
                    generateGreenscreen();
                }
            });
        });

        // é»˜è®¤é€‰ä¸­16:9 å’Œ æ¨ªå‘
        document.querySelector('[data-ratio="16:9"]').classList.add('active');
        document.querySelector('[data-orientation="landscape"]').classList.add('active');

        // æ–¹å‘åˆ‡æ¢
        document.querySelectorAll('.orientation-btn').forEach(btn => {
            btn.addEventListener('click', function () {
                document.querySelectorAll('.orientation-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                orientation = this.dataset.orientation;
                // åˆ‡æ¢æ–¹å‘åç«‹å³é‡ç»˜
                generateGreenscreen();
            })
        });

        // è‡ªå®šä¹‰è¾“å…¥ç›‘å¬
        document.getElementById('custom-width').addEventListener('input', updateCustomRatio);
        document.getElementById('custom-height').addEventListener('input', updateCustomRatio);

        function updateCustomRatio() {
            const width = document.getElementById('custom-width').value;
            const height = document.getElementById('custom-height').value;

            if (width && height) {
                document.querySelectorAll('.aspect-btn[data-ratio]').forEach(b => b.classList.remove('active'));
                currentRatio = `${width}:${height}`;
                // è¾“å…¥æœ‰æ•ˆæ—¶è‡ªåŠ¨æ¸²æŸ“
                generateGreenscreen();
            }
        }

        function generateGreenscreen() {
            let width, height;

            // è·å–è‡ªå®šä¹‰å°ºå¯¸æˆ–ä½¿ç”¨é¢„è®¾æ¯”ä¾‹
            const customWidth = document.getElementById('custom-width').value;
            const customHeight = document.getElementById('custom-height').value;

            let ratioW, ratioH; // ç”¨äºè®¡ç®—æ¯”ä¾‹å±•ç¤ºï¼ˆå·²åº”ç”¨æ–¹å‘ï¼‰
            const isCustom = !!(customWidth && customHeight);

            // è¾…åŠ©ï¼šæŒ‰æ–¹å‘è°ƒæ•´å®½é«˜/æ¯”ä¾‹
            const applyOrientation = (w, h) => {
                if (orientation === 'landscape' && w < h) return [h, w];
                if (orientation === 'portrait' && w > h) return [h, w];
                return [w, h];
            };

            if (isCustom) {
                let w = parseInt(customWidth);
                let h = parseInt(customHeight);
                [w, h] = applyOrientation(w, h);
                width = w; height = h;
                ratioW = w; ratioH = h;
            } else {
                const [wStr, hStr] = currentRatio.split(':');
                let w = Number(wStr);
                let h = Number(hStr);
                [w, h] = applyOrientation(w, h);
                const baseSize = 400; // åŸºç¡€å°ºå¯¸
                const maxWH = Math.max(w, h);
                width = (w / maxWH) * baseSize;
                height = (h / maxWH) * baseSize;
                ratioW = w; ratioH = h;
            }

            const canvas = document.getElementById('greenscreen-canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = width;
            canvas.height = height;

            // ç»˜åˆ¶ç»¿å¹•èƒŒæ™¯ï¼ˆçº¯è‰²ï¼‰
            ctx.fillStyle = '#00B140';
            ctx.fillRect(0, 0, width, height);

            // æ— çº¹ç†çº¿æ¡ï¼Œä¿æŒçº¯è‰²èƒŒæ™¯
            // å‚è€ƒæ–œçº¿ï¼šä»å³ä¸Šè§’åˆ°å·¦ä¸‹è§’
            ctx.strokeStyle = '#00D4AA';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width, 0);
            ctx.lineTo(0, height);
            ctx.stroke();

            // æ¯”ä¾‹æ–‡æ¡ˆï¼šé¢„è®¾ç›´æ¥æ˜¾ç¤º currentRatioï¼›è‡ªå®šä¹‰æ—¶æŒ‰å°è¾¹å½’ä¸€åˆ° 1ï¼Œä¿ç•™ 1 ä½å°æ•°
            let aspectText;
            if (isCustom) {
                const minSide = Math.min(ratioW, ratioH);
                const normW = (ratioW / minSide).toFixed(1);
                const normH = (ratioH / minSide).toFixed(1);
                aspectText = `${normW}:${normH}`;
            } else {
                const [wTok, hTok] = currentRatio.split(':');
                // é¢„è®¾æŒ‰æ–¹å‘æ˜¾ç¤ºï¼ˆä¸æŠ˜ç®—ï¼‰
                if (orientation === 'landscape') {
                    aspectText = (Number(wTok) >= Number(hTok)) ? `${wTok}:${hTok}` : `${hTok}:${wTok}`;
                } else {
                    aspectText = (Number(wTok) <= Number(hTok)) ? `${wTok}:${hTok}` : `${hTok}:${wTok}`;
                }
            }
            const p1 = 'Green screen - Update the input image by replacing the green screen according to the description provided on it.';
            const p2 = `The aspect ratio of this image is ${aspectText}`;
            const p3 = 'Do not change the input aspect ratio.';

            // æ–‡æœ¬æ ·å¼ä¸è‡ªåŠ¨æ¢è¡Œ
            ctx.fillStyle = '#00D4AA';
            const fontSize = Math.min(width, height) / 15;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const lineHeight = fontSize * 1.2; // è¡Œé«˜
            const paddingXConst = fontSize * 0.4;
            const paddingYConst = fontSize * 0.3;
            const maxTextWidth = Math.max(10, width - 2 * paddingXConst - 8); // ç¡®ä¿åŒ…å«å†…è¾¹è·ä¹Ÿä¸è¶Šç•Œ
            function wrapText(context, text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let line = '';
                for (let n = 0; n < words.length; n++) {
                    const testLine = line ? line + ' ' + words[n] : words[n];
                    const metrics = context.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && line) {
                        lines.push(line);
                        line = words[n];
                    } else {
                        line = testLine;
                    }
                }
                if (line) lines.push(line);
                return lines;
            }

            const wrapped1 = wrapText(ctx, p1, maxTextWidth);
            const wrapped2 = wrapText(ctx, p2, maxTextWidth);
            const wrapped3 = wrapText(ctx, p3, maxTextWidth);
            const allLines = [...wrapped1, '', '', ...wrapped2, '', '', ...wrapped3];
            const nonEmptyCount = allLines.filter(l => l).length;
            const totalSpan = (allLines.length - 1) * lineHeight + nonEmptyCount * paddingYConst;
            let startY = height / 2 - totalSpan / 2;
            allLines.forEach((line, i) => {
                const y = startY + i * lineHeight;
                if (line) {
                    const textWidth = ctx.measureText(line).width;
                    const paddingX = fontSize * 0.4;
                    const paddingY = fontSize * 0.3;
                    // èƒŒæ™¯é®æŒ¡çŸ©å½¢
                    ctx.fillStyle = '#00B140';
                    ctx.fillRect((width - textWidth) / 2 - paddingX,
                        y - lineHeight / 2 - paddingY / 2,
                        textWidth + paddingX * 2,
                        lineHeight + paddingY);
                    // å‰æ™¯æ–‡å­—
                    ctx.fillStyle = '#00D4AA';
                    ctx.fillText(line, width / 2, y);
                }
            });

            // æ›´æ–°æç¤ºè¯
            updatePromptText();

            // æ˜¾ç¤ºç»“æœåŒºåŸŸ
            document.getElementById('result-section').classList.add('show');
        }

        function updatePromptText() {
            const promptTemplate = `{{ File: Original Image }}

Update the input image by replacing the green screen according to the description provided on it, ensuring that the new scene blends seamlessly as a whole. The final image should have no green screen(#00B140), reference lines(#00D4AA), borders(#00D4AA) or text description(#00D4AA) visible.

\`\`\`yaml
{{ YAMLæ ¼å¼æç¤ºè¯ }}
\`\`\`

Do not change the input aspect ratio.

Return the drawn picture.`;

            const promptTemplate2 = `{{ File: Original Image }}

Create a new image by combining the elements from the provided images. Take the [element from image 1] and place it with/on the [element from image 2]. The final image should ensure that the new scene blends seamlessly as a whole.

\`\`\`yaml
{{ YAMLæ ¼å¼æç¤ºè¯ }}
\`\`\`

Do not change the input aspect ratio.

Return the drawn picture.`;

            document.getElementById('prompt-text').textContent = promptTemplate;
            document.getElementById('prompt-text2').textContent = promptTemplate2;
        }

        function downloadImage(scale = 1) {
            const link = document.createElement('a');
            const s = Math.max(1, Math.floor(scale));
            const orientTag = (typeof orientation !== 'undefined' && orientation === 'portrait') ? 'portrait' : 'landscape';
            const labelTag = (typeof currentLabel !== 'undefined' && currentLabel) ? currentLabel : 'preset';
            const ratioTag = (typeof currentRatio !== 'undefined' && currentRatio ? currentRatio : '16:9').replace(':', 'x');

            let dataUrl;
            if (window.__exportWorkspacePNG) {
                dataUrl = window.__exportWorkspacePNG(s);
            } else {
                // å›é€€ï¼šç›´æ¥å¯¼å‡ºå½“å‰ç”»å¸ƒ
                const canvas = document.getElementById('greenscreen-canvas');
                dataUrl = canvas.toDataURL('image/png');
            }

            link.download = `workspace_${labelTag}_${orientTag}_${ratioTag}_${s}x.png`;
            link.href = dataUrl;
            link.click();
        }

        function copyPrompt() {
            const promptText = document.getElementById('prompt-text').textContent;
            const copyBtn = document.getElementById('copy-btn1');

            navigator.clipboard.writeText(promptText).then(() => {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'âœ… å·²å¤åˆ¶ Copied!';
                copyBtn.classList.add('copy-success');

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.classList.remove('copy-success');
                }, 2000);
            }).catch(err => {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                // é™çº§æ–¹æ¡ˆ
                const textArea = document.createElement('textarea');
                textArea.value = promptText;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'âœ… å·²å¤åˆ¶ Copied!';
                copyBtn.classList.add('copy-success');

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.classList.remove('copy-success');
                }, 2000);
            });
        }

        function copyPrompt2() {
            const promptText = document.getElementById('prompt-text2').textContent;
            const copyBtn = document.getElementById('copy-btn2');

            navigator.clipboard.writeText(promptText).then(() => {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'âœ… å·²å¤åˆ¶ Copied!';
                copyBtn.classList.add('copy-success');

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.classList.remove('copy-success');
                }, 2000);
            }).catch(err => {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                // é™çº§æ–¹æ¡ˆ
                const textArea = document.createElement('textarea');
                textArea.value = promptText;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'âœ… å·²å¤åˆ¶ Copied!';
                copyBtn.classList.add('copy-success');

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.classList.remove('copy-success');
                }, 2000);
            });
        }

        // é¡µé¢åŠ è½½æ—¶ç”Ÿæˆé»˜è®¤ç»¿å¹•
        window.addEventListener('load', () => {
            generateGreenscreen();
        });

        (function () {
            // æ³¨å…¥å°‘é‡æ ·å¼ï¼ˆå·¥å…·æ ä¸æ ‡ç­¾åˆ—è¡¨ï¼‰
            const css = `
    .workspace-toolbar { margin: 12px 0 8px; display: grid; grid-template-columns: 1fr; gap: 8px; }
    .workspace-toolbar .ws-controls { display: flex; gap: 8px; flex-wrap: wrap; }
    .workspace-toolbar button { background:#00B140; color:#fff; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600; }
    .ws-group { border:1px dashed #e9ecef; padding:8px; border-radius:6px; }
    .ws-group-title { font-weight:700; color:#333; margin-right:8px; white-space:nowrap; }
    .workspace-toolbar button:hover { filter:brightness(0.95); }
    .ws-mask-list { display:flex; flex-direction: column; gap: 6px; }
    .ws-mask-item { display:flex; align-items:center; gap:8px; }
    .ws-mask-item input { flex:1; padding:6px 8px; border:1px solid #e9ecef; border-radius:4px; }
    .ws-tip { color:#666; font-size: 12px; }
    `;
            const st = document.createElement('style');
            st.textContent = css;
            document.head.appendChild(st);

            const resultSection = document.getElementById('result-section');
            if (!resultSection) return;

            // æ„å»ºå·¥å…·æ ï¼ˆä¸Šä¼ /æ·»åŠ ç»¿å¹•/å¯¼å‡º + æ ‡ç­¾åˆ—è¡¨ï¼‰ï¼Œæ’å…¥åˆ°ç°æœ‰ç”»å¸ƒä¸Šæ–¹
            const toolbar = document.createElement('div');
            toolbar.className = 'workspace-toolbar';
            toolbar.innerHTML = `
        <div class="ws-controls ws-group">
            <span class="ws-group-title">å‚è€ƒå›¾ï¼ˆImageï¼‰å·¥å…·ï½œä½œç”¨å¯¹è±¡ï¼šé€‰ä¸­å›¾ç‰‡</span>
            <input id="ws-upload" type="file" accept="image/*" multiple title="å¯¼å…¥å‚è€ƒå›¾ï¼ˆä½œç”¨äºå›¾ç‰‡å¯¹è±¡ï¼‰">
            <button id="ws-rot-left" type="button" title="å¯¹é€‰ä¸­å›¾ç‰‡æ—‹è½¬ -15Â°">â†º æ—‹è½¬-15Â°</button>
            <button id="ws-rot-right" type="button" title="å¯¹é€‰ä¸­å›¾ç‰‡æ—‹è½¬ +15Â°">â†» æ—‹è½¬+15Â°</button>
            <label style="display:flex;align-items:center;gap:6px;" title="å¯¹é€‰ä¸­å›¾ç‰‡è®¾ç½®æ—‹è½¬è§’åº¦">
                è§’åº¦
                <input id="ws-rot-range" type="range" min="-180" max="180" step="1" value="0" style="width:120px;">
                <input id="ws-rot-input" type="number" min="-180" max="180" step="1" value="0" style="width:70px;">
            </label>
            <button id="ws-flip-h" type="button" title="å¯¹é€‰ä¸­å›¾ç‰‡è¿›è¡Œæ°´å¹³ç¿»è½¬">â‡‹ æ°´å¹³ç¿»è½¬</button>
            <button id="ws-flip-v" type="button" title="å¯¹é€‰ä¸­å›¾ç‰‡è¿›è¡Œå‚ç›´ç¿»è½¬">â‡… å‚ç›´ç¿»è½¬</button>
        </div>
        <div class="ws-controls ws-group">
            <span class="ws-group-title">ç»¿å¹•ï¼ˆMaskï¼‰å·¥å…·ï½œä½œç”¨å¯¹è±¡ï¼šé€‰ä¸­ç»¿å¹•ï¼›æ–‡æ¡ˆæ˜¾ç¤ºä¸ºå…¨å±€</span>
            <button id="ws-add-mask" type="button" title="åœ¨å·¥ä½œåŒºæ·»åŠ å¯æ‹–æ‹½çš„ç»¿å¹•é®ç½©">â• æ·»åŠ ç»¿å¹•</button>
            <label style="display:flex;align-items:center;gap:6px;" title="åˆ‡æ¢æ˜¯å¦åœ¨æ‰€æœ‰ç»¿å¹•ä¸Šæ˜¾ç¤ºä¸‰æ®µæ–‡æ¡ˆï¼ˆå…¨å±€ï¼‰">
                <input id="ws-toggle-text" type="checkbox" checked>
                æ˜¾ç¤ºé®ç½©æ–‡æ¡ˆï¼ˆå…¨å±€ï¼‰å‹¾é€‰åå¯åœ¨å›¾å±‚åˆ—è¡¨ä¸­å•ç‹¬æ§åˆ¶
            </label>
        </div>
        <div class="ws-tip">æç¤ºï¼šæ‹–æ‹½ç§»åŠ¨ï¼›æ‹–æ‹½å³ä¸‹è§’ç¼©æ”¾ï¼›å›¾ç‰‡ä¿æŒå®½é«˜æ¯”ï¼›ç»¿å¹•å¯è‡ªç”±ç¼©æ”¾ï¼›æœ€å¤šå¯¼å…¥ 10 å¼ å›¾ç‰‡ã€‚</div>
        <!-- æ—§çš„ç»¿å¹•é¢æ¿éšè—ï¼Œå·²åˆå¹¶åˆ°ä¸‹æ–¹â€œå›¾å±‚æ â€ -->
        <div id="ws-mask-list" class="ws-mask-list" style="display:none;"></div>
    `;
            const canvasContainer = resultSection.querySelector('.canvas-container');
            resultSection.insertBefore(toolbar, canvasContainer);

            // æ„å»ºå›¾å±‚æ ï¼ˆä½äºå·¥ä½œåŒºä¸‹æ–¹ï¼Œä¸å½±å“å·¥ä½œåŒºæ¯”ä¾‹ï¼‰
            const promptSection = resultSection.querySelector('.prompt-section');
            const layersPanel = document.createElement('div');
            layersPanel.id = 'ws-layers-panel';
            layersPanel.className = 'ws-layers-panel';
            layersPanel.innerHTML = `
                <div class="ws-layers-header">
                    <span class="ws-group-title">å›¾å±‚ï¼ˆLayersï¼‰</span>
                    <div style="flex:1;"></div>
                    <button id="ws-layers-toggle" type="button">æ”¶èµ·</button>
                </div>
                <div id="ws-layers-content" class="ws-layers-content"></div>
            `;
            if (promptSection) {
                resultSection.insertBefore(layersPanel, promptSection);
            } else {
                resultSection.appendChild(layersPanel);
            }
            let layersCollapsed = false;
            const layersToggleBtn = layersPanel.querySelector('#ws-layers-toggle');
            layersToggleBtn.addEventListener('click', () => {
                layersCollapsed = !layersCollapsed;
                if (layersCollapsed) {
                    layersPanel.classList.add('collapsed');
                    layersToggleBtn.textContent = 'å±•å¼€';
                } else {
                    layersPanel.classList.remove('collapsed');
                    layersToggleBtn.textContent = 'æ”¶èµ·';
                }
            });

            // æ—‹è½¬/ç¿»è½¬æ§ä»¶é€»è¾‘
            const rotLeftBtn  = toolbar.querySelector('#ws-rot-left');
            const rotRightBtn = toolbar.querySelector('#ws-rot-right');
            const rotRange    = toolbar.querySelector('#ws-rot-range');
            const rotInput    = toolbar.querySelector('#ws-rot-input');
            const flipHBtn    = toolbar.querySelector('#ws-flip-h');
            const flipVBtn    = toolbar.querySelector('#ws-flip-v');

            function degToRad(d){ return (d * Math.PI) / 180; }
            function radToDeg(r){ return Math.round((r * 180) / Math.PI); }
            function normalizeAngle(r){
                while (r >  Math.PI) r -= 2*Math.PI;
                while (r <= -Math.PI) r += 2*Math.PI;
                return r;
            }
            function getSelectedImage(){
                // ä½¿ç”¨ try/catch é¿å… TDZï¼šstate åœ¨åˆå§‹åŒ–å‰è®¿é—®ä¼šæŠ› ReferenceError
                try {
                    const o = state?.objects?.[state.selected];
                    return (o && o.type === 'image') ? o : null;
                } catch (e) {
                    return null;
                }
            }
            function syncRotationUI(){
                const img = getSelectedImage();
                const deg = img ? radToDeg(img.rotation || 0) : 0;
                if (rotRange) rotRange.value = String(deg);
                if (rotInput) rotInput.value = String(deg);
            }
            function applyRotation(deltaDeg){
                const img = getSelectedImage();
                if (!img) return;
                img.rotation = normalizeAngle((img.rotation || 0) + degToRad(deltaDeg));
                syncRotationUI();
                render();
            }
            if (rotLeftBtn)  rotLeftBtn.addEventListener('click', () => applyRotation(-15));
            if (rotRightBtn) rotRightBtn.addEventListener('click', () => applyRotation(+15));
            if (rotRange) rotRange.addEventListener('input', (e) => {
                const img = getSelectedImage(); if (!img) return;
                const val = Number(e.target.value || 0);
                img.rotation = normalizeAngle(degToRad(val));
                if (rotInput) rotInput.value = String(val);
                render();
            });
            if (rotInput) rotInput.addEventListener('input', (e) => {
                const img = getSelectedImage(); if (!img) return;
                const raw = Number(e.target.value || 0);
                const val = Math.max(-180, Math.min(180, raw));
                img.rotation = normalizeAngle(degToRad(val));
                if (rotRange) rotRange.value = String(val);
                render();
            });
            if (flipHBtn) flipHBtn.addEventListener('click', () => {
                const img = getSelectedImage(); if (!img) return;
                img.flipH = !img.flipH;
                render();
            });
            if (flipVBtn) flipVBtn.addEventListener('click', () => {
                const img = getSelectedImage(); if (!img) return;
                img.flipV = !img.flipV;
                render();
            });
            // åˆå§‹åŒæ­¥ä¸€æ¬¡
            // å»¶è¿Ÿåˆ°å½“å‰å®ä»»åŠ¡åæ‰§è¡Œï¼Œç¡®ä¿ state å·²åˆå§‹åŒ–
            setTimeout(() => syncRotationUI(), 0);
            
            // å·¥ä½œç©ºé—´å®½é«˜æ¯”ï¼šæ§ä»¶ + è¦†ç›–é€»è¾‘ï¼ˆä¸æ”¹åŠ¨ç°æœ‰ UI çš„é¢„è®¾æ¯”ä¾‹ï¼Œæ”¯æŒå•ç‹¬è®¾ç½®å·¥ä½œåŒºï¼‰
            let workspaceRatioOverride = null;

            // æ„å»ºâ€œå·¥ä½œç©ºé—´å®½é«˜æ¯”â€æ§ä»¶è¡Œ
            const wsRatioRow = document.createElement('div');
            wsRatioRow.className = 'ws-controls';
            wsRatioRow.innerHTML = `
            <span class="ws-group-title">å·¥ä½œåŒºæ¯”ä¾‹è®¾ç½®ï½œä½œç”¨å¯¹è±¡ï¼šå·¥ä½œç©ºé—´</span>
            <input id="ws-ratio-w" type="number" min="1" placeholder="å·¥ä½œåŒºå®½W" style="width:100px;padding:6px 8px;border:1px solid #e9ecef;border-radius:4px;" title="å·¥ä½œåŒºå®½ï¼ˆWï¼‰">
            <span>:</span>
            <input id="ws-ratio-h" type="number" min="1" placeholder="é«˜H" style="width:100px;padding:6px 8px;border:1px solid #e9ecef;border-radius:4px;" title="å·¥ä½œåŒºé«˜ï¼ˆHï¼‰">
            <button id="ws-apply-ratio" type="button" title="å°†å·¦ä¾§å®½é«˜åº”ç”¨åˆ°å·¥ä½œç©ºé—´æ¯”ä¾‹">åº”ç”¨å·¥ä½œåŒºæ¯”ä¾‹</button>
            <button id="ws-apply-top" type="button" title="ä½¿ç”¨ä¸Šæ–¹é¢„è®¾æ¯”ä¾‹ï¼ˆå«æ–¹å‘ï¼‰è¦†ç›–ä¸ºå·¥ä½œåŒºæ¯”ä¾‹">åº”ç”¨ä¸Šæ–¹æ¯”ä¾‹</button>
            `;

            // æ’å…¥åˆ°æç¤ºè¡Œä¹‹å‰
            const wsTipEl = toolbar.querySelector('.ws-tip');
            toolbar.insertBefore(wsRatioRow, wsTipEl);

            // å¡«å……è¾“å…¥æ¡†ä¸ºå½“å‰ä¸Šæ–¹é€‰æ‹©çš„æ¯”ä¾‹ï¼ˆä»…åœ¨æœªè¦†ç›–æ—¶åŒæ­¥ï¼‰
            function __wsFillRatioInputs() {
            try {
                const raw = (currentRatio || '16:9').split(':');
                let w = Number(raw[0]), h = Number(raw[1]);
                if (orientation === 'landscape' && w < h) [w, h] = [h, w];
                if (orientation === 'portrait' && w > h) [w, h] = [h, w];
                const wEl = wsRatioRow.querySelector('#ws-ratio-w');
                const hEl = wsRatioRow.querySelector('#ws-ratio-h');
                if (wEl && hEl && !workspaceRatioOverride) { wEl.value = w; hEl.value = h; }
            } catch (e) {}
            }
            __wsFillRatioInputs();

            // äº‹ä»¶ï¼šåº”ç”¨/æ¸…é™¤è¦†ç›–
            wsRatioRow.querySelector('#ws-apply-ratio').addEventListener('click', () => {
            let w = Number(wsRatioRow.querySelector('#ws-ratio-w').value);
            let h = Number(wsRatioRow.querySelector('#ws-ratio-h').value);
            // è‹¥æœªåœ¨æœ¬è¡Œè¾“å…¥ï¼Œåˆ™å›é€€è¯»å–é¡µé¢é¡¶éƒ¨â€œè‡ªå®šä¹‰å®½é«˜â€è¾“å…¥æ¡†
            if (!(w > 0 && h > 0)) {
                const cwEl = document.getElementById('custom-width');
                const chEl = document.getElementById('custom-height');
                const cw = Number(cwEl && cwEl.value);
                const ch = Number(chEl && chEl.value);
                if (cw > 0 && ch > 0) {
                    w = cw; h = ch;
                    // åŒæ­¥å›å¡«åˆ°æœ¬è¡Œè¾“å…¥ï¼Œä¾¿äºåç»­è°ƒæ•´
                    const wEl = wsRatioRow.querySelector('#ws-ratio-w');
                    const hEl = wsRatioRow.querySelector('#ws-ratio-h');
                    if (wEl && hEl) { wEl.value = String(w); hEl.value = String(h); }
                }
            }
            // å†æ¬¡æ— æ•ˆåˆ™å›é€€åˆ°å½“å‰ä¸Šæ–¹é€‰æ‹©çš„æ¯”ä¾‹ currentRatio
            if (!(w > 0 && h > 0)) {
                try {
                    const raw = (currentRatio || '16:9').split(':');
                    const rw = Number(raw[0]), rh = Number(raw[1]);
                    if (rw > 0 && rh > 0) { w = rw; h = rh; }
                } catch (e) {}
            }
            if (w > 0 && h > 0) {
                workspaceRatioOverride = { w, h };
                updateWorkspaceSize();
            }
            });

            // åº”ç”¨ä¸Šæ–¹æ¯”ä¾‹ï¼šå°†å½“å‰ä¸Šæ–¹é€‰æ‹©ï¼ˆå«æ–¹å‘ï¼‰å†™å…¥è¦†ç›–å¹¶é‡ç»˜
            wsRatioRow.querySelector('#ws-apply-top').addEventListener('click', () => {
                try {
                    const raw = (currentRatio || '16:9').split(':');
                    let w = Number(raw[0]), h = Number(raw[1]);
                    if (orientation === 'landscape' && w < h) [w, h] = [h, w];
                    if (orientation === 'portrait' && w > h) [w, h] = [h, w];
                    workspaceRatioOverride = { w, h };
                    const wEl = wsRatioRow.querySelector('#ws-ratio-w');
                    const hEl = wsRatioRow.querySelector('#ws-ratio-h');
                    if (wEl && hEl) { wEl.value = w; hEl.value = h; }
                    updateWorkspaceSize();
                } catch (e) {}
            });

            // å›è½¦å¿«æ·åº”ç”¨
            ['#ws-ratio-w', '#ws-ratio-h'].forEach(sel => {
            const el = wsRatioRow.querySelector(sel);
            el.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') wsRatioRow.querySelector('#ws-apply-ratio').click();
            });
            });

            // è¦†ç›– ratioPairï¼šä¼˜å…ˆä½¿ç”¨å·¥ä½œåŒºè‡ªå®šä¹‰å®½é«˜æ¯”ï¼›å¦åˆ™å›é€€åŸé€»è¾‘
            const __ratioPairOrig = ratioPair;
            ratioPair = function () {
            if (workspaceRatioOverride && workspaceRatioOverride.w > 0 && workspaceRatioOverride.h > 0) {
                let w = workspaceRatioOverride.w, h = workspaceRatioOverride.h;
                if (orientation === 'landscape' && w < h) [w, h] = [h, w];
                if (orientation === 'portrait' && w > h) [w, h] = [h, w];
                return [w, h];
            }
            return __ratioPairOrig();
            };

            // å½“ç”¨æˆ·ç‚¹å‡»ä¸Šæ–¹é¢„è®¾æ¯”ä¾‹æˆ–æ–¹å‘ä¸”æœªè¦†ç›–æ—¶ï¼ŒåŒæ­¥è¾“å…¥æ¡†æ˜¾ç¤º
            document.querySelectorAll('.aspect-btn[data-ratio], .orientation-btn').forEach(b => {
            b.addEventListener('click', () => setTimeout(() => {
                if (!workspaceRatioOverride) __wsFillRatioInputs();
            }, 0));
            });
            // å¤ç”¨å·²æœ‰ canvas ä½œä¸ºå·¥ä½œç©ºé—´
            const canvas = document.getElementById('greenscreen-canvas');
            const ctx = canvas.getContext('2d');

            // è¾“å…¥æ¡†èšç„¦æ—¶è·³è¿‡å›¾å±‚æ åˆ·æ–°ï¼Œé¿å…é‡å»ºå¯¼è‡´å¤±ç„¦
            let __skipLayersRefresh = false;

            const state = {
                dpr: window.devicePixelRatio || 1,
                cssW: 0,
                cssH: 0,
                showTexts: false,
                objects: [], // { type:'image'|'mask', x,y,w,h, img?, label? }
                selected: -1,
                dragging: null, // { mode:'move'|'resize', dx,dy } for move; resize uses bottom-right handle
            };

            // å¾ªç¯ç¼–å·æ± ï¼šå›¾ç‰‡æœ€å¤š10ï¼ŒMaskæœ€å¤š15
            const IMAGE_MAX = 10;
            const MASK_MAX = 15;
            state.imageIdsUsed = new Set();
            state.maskIdsUsed = new Set();
            state.imageNext = 1;
            state.maskNext = 1;

            function __allocSeq(usedSet, nextKey, max) {
                let n = state[nextKey] || 1;
                for (let tries = 0; tries < max; tries++) {
                    if (!usedSet.has(n)) {
                        usedSet.add(n);
                        state[nextKey] = (n % max) + 1;
                        return n;
                    }
                    n = (n % max) + 1;
                }
                return null;
            }
            function allocateImageSeq() { return __allocSeq(state.imageIdsUsed, 'imageNext', IMAGE_MAX); }
            function allocateMaskSeq() { return __allocSeq(state.maskIdsUsed, 'maskNext', MASK_MAX); }
            function releaseImageSeq(n) { if (typeof n === 'number') state.imageIdsUsed.delete(n); }
            function releaseMaskSeq(n) { if (typeof n === 'number') state.maskIdsUsed.delete(n); }

            function ratioPair() {
                const wsToggleEl = toolbar.querySelector('#ws-toggle-text');
                if (wsToggleEl) {
                    wsToggleEl.checked = !!state.showTexts;
                    wsToggleEl.addEventListener('change', (e) => {
                        state.showTexts = !!e.target.checked;
                        render();
                    });
                }
                const raw = (currentRatio || '16:9').split(':');
                let w = Number(raw[0]), h = Number(raw[1]);
                if (orientation === 'landscape' && w < h) [w, h] = [h, w];
                if (orientation === 'portrait' && w > h) [w, h] = [h, w];
                return [w, h];
            }

            function updateWorkspaceSize() {
                const prevW = state.cssW || 0;
                const prevH = state.cssH || 0;

                const containerWidth = resultSection.clientWidth - 40; // é€‚åº¦å†…è¾¹è·
                const maxW = Math.max(300, containerWidth);
                const [rw, rh] = ratioPair();
                const cssW = maxW;
                const cssH = Math.round(cssW * (rh / rw));

                state.cssW = cssW;
                state.cssH = cssH;

                const dpr = window.devicePixelRatio || 1;
                state.dpr = dpr;
                canvas.style.width = cssW + 'px';
                canvas.style.height = cssH + 'px';
                canvas.width = Math.round(cssW * dpr);
                canvas.height = Math.round(cssH * dpr);

                // å°ºå¯¸å˜åŒ–æ—¶æŒ‰æ¯”ä¾‹æ•´ä½“ç¼©æ”¾å¯¹è±¡ï¼Œä¿æŒå¸ƒå±€å¤§ä½“ä¸€è‡´
                if (prevW && prevH && (prevW !== cssW || prevH !== cssH)) {
                    const sx = cssW / prevW;
                    const sy = cssH / prevH;
                    state.objects.forEach(o => {
                        o.x *= sx; o.y *= sy; o.w *= sx; o.h *= sy;
                    });
                }

                render();
            }

            function render() {
                const dpr = state.dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                ctx.clearRect(0, 0, state.cssW, state.cssH);

                // èƒŒæ™¯ï¼šçº¯ç™½
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, state.cssW, state.cssH);

                state.objects.forEach((obj, idx) => {
                    if (obj.type === 'image') {
                        if (obj.img) {
                            ctx.save();
                            const cx = obj.x + obj.w / 2;
                            const cy = obj.y + obj.h / 2;
                            const rot = obj.rotation || 0;
                            const sX = obj.flipH ? -1 : 1;
                            const sY = obj.flipV ? -1 : 1;
                            ctx.translate(cx, cy);
                            ctx.scale(sX, sY);
                            if (rot) ctx.rotate(rot);
                            ctx.drawImage(obj.img, -obj.w / 2, -obj.h / 2, obj.w, obj.h);
                            ctx.restore();
                        }
                        // ä¸ºå›¾ç‰‡å¯¹è±¡ç»˜åˆ¶å·¦ä¸Šè§’æ ‡ç­¾ï¼ˆä¸å›¾å±‚æ åç§°ä¸€è‡´ï¼Œä¸å¯ç¼–è¾‘ï¼‰
                        const __imgTag = obj.seqName || obj.label;
                        if (__imgTag) {
                            ctx.save();
                            ctx.font = 'bold 12px Arial';
                            ctx.textBaseline = 'top';
                            ctx.textAlign = 'start';
                            const padX = 6, padY = 4;
                            const tx = obj.x + 6, ty = obj.y + 6;
                            const tw = ctx.measureText(__imgTag).width;
                            const th = 14; // æ–‡å­—é«˜åº¦è¿‘ä¼¼
                            ctx.fillStyle = '#00B140';
                            ctx.fillRect(tx - padX, ty - padY, tw + padX * 2, th + padY * 2);
                            ctx.fillStyle = '#00D4AA';
                            ctx.fillText(__imgTag, tx, ty);
                            ctx.restore();
                        }
                    } else if (obj.type === 'mask') {
                        // ç»¿å¹•
                        ctx.fillStyle = '#00B140';
                        ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
                        ctx.strokeStyle = '#00D4AA';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
                        if (state.showTexts && (obj.showText !== false)) {
                            // å‚è€ƒæ–œçº¿ï¼šä»å³ä¸Šè§’åˆ°å·¦ä¸‹è§’
                            ctx.strokeStyle = '#00D4AA';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(obj.x + obj.w, obj.y);
                            ctx.lineTo(obj.x, obj.y + obj.h);
                            ctx.stroke();

                            // æ ‡ç­¾ï¼šå·¦ä¸Šè§’
                            ctx.fillStyle = '#00D4AA';
                            ctx.font = 'bold 14px Arial';
                            ctx.textBaseline = 'top';
                            ctx.textAlign = 'start';
                            ctx.fillText(obj.label || 'Mask', obj.x + 6, obj.y + 6);

                            // ä¸‰è¡Œæ–‡æ¡ˆï¼ˆè‡ªé€‚åº”é®ç½©å°ºå¯¸ï¼‰
                            (function drawMaskTexts() {
                                const minSide = Math.min(obj.w, obj.h);
                                const normW = (obj.w / minSide).toFixed(1);
                                const normH = (obj.h / minSide).toFixed(1);
                                const aspectText = `${normW}:${normH}`;

                                const p1 = 'Green screen - Update the input image by replacing the green screen according to the description provided on it.';
                                const p2 = `The aspect ratio of this image is ${aspectText}`;
                                const p3 = 'Do not change the input aspect ratio.';

                                // å¯ç”¨æ–‡å­—åŒºåŸŸï¼ˆä¸ºå·¦ä¸Šè§’æ ‡ç­¾å’Œåº•éƒ¨ç•™å‡ºå®‰å…¨è·ç¦»ï¼‰
                                const safeTop = obj.y + 6 + 14 + 8; // æ ‡ç­¾(14px) + padding
                                const safeBottom = obj.y + obj.h - 8;
                                const boxY = safeTop;
                                const boxH = Math.max(10, safeBottom - safeTop);
                                const boxX = obj.x;
                                const boxW = obj.w;

                                function wrapText(context, text, maxWidth) {
                                    const words = text.split(' ');
                                    const lines = [];
                                    let line = '';
                                    for (let n = 0; n < words.length; n++) {
                                        const testLine = line ? line + ' ' + words[n] : words[n];
                                        const metrics = context.measureText(testLine);
                                        if (metrics.width > maxWidth && line) {
                                            lines.push(line);
                                            line = words[n];
                                        } else {
                                            line = testLine;
                                        }
                                    }
                                    if (line) lines.push(line);
                                    return lines;
                                }

                                // åˆå§‹å­—å·æŒ‰æœ€çŸ­è¾¹ä¼°ç®—ï¼Œéšåè‡ªé€‚åº”ç¼©å°ç›´è‡³é«˜åº¦å¯å®¹çº³
                                let fitFS = Math.min(obj.w, obj.h) / 12;
                                let lines = [];
                                let lineHeightLocal = 0;

                                for (let i = 0; i < 10; i++) {
                                    ctx.save();
                                    const paddingX = fitFS * 0.4;
                                    const paddingY = fitFS * 0.3;
                                    const maxTextWidth = Math.max(10, boxW - 2 * paddingX - 8);

                                    ctx.font = `bold ${fitFS}px Arial`;
                                    const w1 = wrapText(ctx, p1, maxTextWidth);
                                    const w2 = wrapText(ctx, p2, maxTextWidth);
                                    const w3 = wrapText(ctx, p3, maxTextWidth);
                                    ctx.restore();

                                    lines = [...w1, '', '', ...w2, '', '', ...w3];
                                    lineHeightLocal = fitFS * 1.2;

                                    const nonEmpty = lines.filter(Boolean).length;
                                    const totalSpan = (lines.length - 1) * lineHeightLocal + nonEmpty * paddingY;

                                    if (totalSpan <= boxH) break;

                                    const ratio = Math.max(0.5, boxH / (totalSpan + 0.0001));
                                    fitFS = Math.max(6, fitFS * ratio * 0.98);
                                }

                                const paddingY = fitFS * 0.3;
                                const nonEmpty = lines.filter(Boolean).length;
                                const totalSpan = (lines.length - 1) * lineHeightLocal + nonEmpty * paddingY;
                                // å°†èµ·å§‹ Y é’³åˆ¶ï¼Œä¿è¯é¦–è¡ŒèƒŒæ™¯çŸ©å½¢é¡¶éƒ¨ä¸è¶Šè¿‡æ ‡ç­¾å®‰å…¨åŒº
                                let startY = Math.max(
                                    boxY + lineHeightLocal / 2 + paddingY / 2,
                                    boxY + (boxH - totalSpan) / 2
                                );

                                // è£å‰ªåˆ°æ–‡æœ¬å¯ç”¨åŒºåŸŸï¼Œé¿å…è¶…å®½æ¯”æ—¶è¶Šç•Œè¢«â€œç¡¬æˆªæ–­â€çš„è§†è§‰é—®é¢˜
                                ctx.save();
                                ctx.beginPath();
                                ctx.rect(boxX, boxY, boxW, boxH);
                                ctx.clip();

                                ctx.font = `bold ${fitFS}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';

                                lines.forEach((line, i) => {
                                    const y = startY + i * lineHeightLocal;
                                    if (line) {
                                        const textWidth = ctx.measureText(line).width;
                                        const paddingX = fitFS * 0.4;
                                        const paddingY = fitFS * 0.3;
                                        // èƒŒæ™¯é®æŒ¡çŸ©å½¢ï¼ˆåœ¨ clip å†…ï¼Œä¸ä¼šä¾µå…¥æ ‡ç­¾ï¼‰
                                        ctx.fillStyle = '#00B140';
                                        ctx.fillRect(
                                            obj.x + (obj.w - textWidth) / 2 - paddingX,
                                            y - lineHeightLocal / 2 - paddingY / 2,
                                            textWidth + paddingX * 2,
                                            lineHeightLocal + paddingY
                                        );
                                        // å‰æ™¯æ–‡å­—
                                        ctx.fillStyle = '#00D4AA';
                                        ctx.fillText(line, obj.x + obj.w / 2, y);
                                    }
                                });
                                ctx.restore();
                            })();
                        } else {
                            // ä»…æ ‡ç­¾ï¼šå±…ä¸­æ˜¾ç¤º
                            ctx.save();
                            ctx.fillStyle = '#00D4AA';
                            ctx.font = 'bold 14px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            // å¢¨ç»¿è‰²èƒŒæ™¯å—ï¼Œå°ºå¯¸åŸºäºæ–‡å­—æµ‹é‡å¹¶ç•™å‡ºå†…è¾¹è·
                            (function () {
                                const label = obj.label || 'Mask';
                                const fs = parseInt(ctx.font, 10) || 14;
                                const paddingX = Math.max(6, fs * 0.6);
                                const paddingY = Math.max(4, fs * 0.4);
                                const textWidth = ctx.measureText(label).width;
                                const cx = obj.x + obj.w / 2;
                                const cy = obj.y + obj.h / 2;

                                // èƒŒæ™¯ä½¿ç”¨å¢¨ç»¿è‰²ï¼Œé£æ ¼ä¸ç»¿å¹•ä¸€è‡´ä¸”æ›´å‹æš—
                                ctx.fillStyle = '#00B140';
                                ctx.fillRect(
                                    cx - textWidth / 2 - paddingX,
                                    cy - fs / 2 - paddingY,
                                    textWidth + paddingX * 2,
                                    fs + paddingY * 2
                                );

                                // å‰æ™¯æ–‡å­—ç»´æŒæµ…ç»¿è‰²
                                ctx.fillStyle = '#00D4AA';
                                ctx.fillText(label, cx, cy);
                            })();
                            ctx.restore();
                        }
                    }

                    // é€‰ä¸­æ€ï¼šè™šçº¿æ¡† + å³ä¸‹è§’ç¼©æ”¾æ‰‹æŸ„
                    if (idx === state.selected) {
                        ctx.save();
                        ctx.strokeStyle = '#006F2A';
                        ctx.setLineDash([6, 4]);
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
                        ctx.setLineDash([]);
                        const hs = 10;
                        ctx.fillStyle = '#006F2A';
                        ctx.fillRect(obj.x + obj.w - hs, obj.y + obj.h - hs, hs, hs);
                        ctx.restore();
                    }
                });
                state.objects.forEach((obj) => {
                    // å›¾ç‰‡ï¼šæ€»æ˜¯è¦†ç›–ç»˜åˆ¶ä¸€æ¬¡å·¦ä¸Šè§’æ ‡ç­¾
                    if (obj.type === 'image') {
                        const __imgTag = obj.seqName || obj.label;
                        if (__imgTag) {
                            ctx.save();
                            ctx.font = 'bold 12px Arial';
                            ctx.textBaseline = 'top';
                            ctx.textAlign = 'start';
                            const padX = 6, padY = 4;
                            const tx = obj.x + 6, ty = obj.y + 6;
                            const tw = ctx.measureText(__imgTag).width;
                            const th = 14;
                            ctx.fillStyle = '#00B140';
                            ctx.fillRect(tx - padX, ty - padY, tw + padX * 2, th + padY * 2);
                            ctx.fillStyle = '#00D4AA';
                            ctx.fillText(__imgTag, tx, ty);
                            ctx.restore();
                        }
                    }
                    // ç»¿å¹•ï¼šä»…åœ¨æ˜¾ç¤ºæ–‡æ¡ˆæ¨¡å¼ä¸‹ï¼ˆå·¦ä¸Šè§’æœ‰æ ‡ç­¾ï¼‰å†å åŠ ä¸€æ¬¡å·¦ä¸Šè§’æ ‡ç­¾
                    else if (obj.type === 'mask' && state.showTexts && (obj.showText !== false)) {
                        ctx.save();
                        ctx.fillStyle = '#00D4AA';
                        ctx.font = 'bold 14px Arial';
                        ctx.textBaseline = 'top';
                        ctx.textAlign = 'start';
                        ctx.fillText(obj.label || 'Mask', obj.x + 6, obj.y + 6);
                        ctx.restore();
                    }
                });
                if (!__skipLayersRefresh && typeof refreshLayersPanel === 'function') {
                    refreshLayersPanel();
                }
            }

            function hitTest(x, y) {
                for (let i = state.objects.length - 1; i >= 0; i--) {
                    const o = state.objects[i];
                    if (x >= o.x && y >= o.y && x <= o.x + o.w && y <= o.y + o.h) {
                        const hs = 12;
                        if (x >= o.x + o.w - hs && y >= o.y + o.h - hs) {
                            return { index: i, onHandle: true };
                        }
                        return { index: i, onHandle: false };
                    }
                }
                return { index: -1, onHandle: false };
            }

            // é¼ æ ‡äº¤äº’
            canvas.addEventListener('mousemove', (e) => {
                if (state.dragging) return; // æ‹–æ‹½ä¸­ä¸æ”¹ cursor
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                const hit = hitTest(x, y);
                if (hit.index >= 0) {
                    canvas.style.cursor = hit.onHandle ? 'nwse-resize' : 'move';
                } else {
                    canvas.style.cursor = 'default';
                }
            });

            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                const hit = hitTest(x, y);
                state.selected = hit.index;

                if (state.selected >= 0) {
                    // ç½®é¡¶
                    const o = state.objects.splice(state.selected, 1)[0];
                    state.objects.push(o);
                    state.selected = state.objects.length - 1;

                    if (hit.onHandle) {
                        state.dragging = { mode: 'resize' };
                        o._aspect = o.w / o.h;
                    } else {
                        state.dragging = { mode: 'move', dx: x - o.x, dy: y - o.y };
                    }
                    canvas.style.cursor = hit.onHandle ? 'nwse-resize' : 'move';
                } else {
                    state.dragging = null;
                    canvas.style.cursor = 'default';
                    if (typeof syncRotationUI === 'function') syncRotationUI();
                }
                render();
            });

            window.addEventListener('mousemove', (e) => {
                if (!state.dragging || state.selected < 0) return;
                const o = state.objects[state.selected];
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;

                if (state.dragging.mode === 'move') {
                    o.x = x - state.dragging.dx;
                    o.y = y - state.dragging.dy;
                } else if (state.dragging.mode === 'resize') {
                    let newW = Math.max(20, x - o.x);
                    let newH = Math.max(20, y - o.y);
                    if (o.type === 'image') {
                        const a = o._aspect || (o.w / o.h);
                        if (newW / newH > a) newW = newH * a;
                        else newH = newW / a;
                    }
                    o.w = newW;
                    o.h = newH;
                }
                render();
            });

            window.addEventListener('mouseup', () => {
                state.dragging = null;
                canvas.style.cursor = 'default';
            });

            // ä¸Šä¼ å›¾ç‰‡ï¼ˆæœ€å¤š 10 å¼ ï¼‰
            document.getElementById('ws-upload').addEventListener('change', (e) => {
                const files = Array.from(e.target.files || []);
                const exists = state.objects.filter(o => o.type === 'image').length;
                const allow = Math.max(0, 10 - exists);
                const chosen = files.slice(0, allow);
                chosen.forEach((file, idx) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const img = new Image();
                        img.onload = () => {
                            const maxW = state.cssW * 0.45;
                            const scale = Math.min(1, maxW / img.width);
                            const w = Math.max(40, img.width * scale);
                            const h = Math.max(40, img.height * scale);
                            const offset = idx * 12;
                            const obj = {
                                type: 'image',
                                img,
                                x: (state.cssW - w) / 2 + offset,
                                y: (state.cssH - h) / 2 + offset,
                                w, h,
                                rotation: 0,
                                flipH: false,
                                flipV: false
                            };

                            // åˆ†é…å›¾ç‰‡åºå·ï¼ˆå¾ªç¯æ±  1..10ï¼‰ï¼Œä¸è¶³åˆ™æç¤º
                            const seq = allocateImageSeq();
                            if (seq == null) { alert('æ— æ³•æ·»åŠ å›¾ç‰‡ï¼šå·²è¾¾åˆ° 10 å¼ ä¸Šé™'); return; }
                            obj.seqId = seq;
                            obj.seqName = `Image ${seq}`;
                            obj.label = obj.seqName;

                            state.objects.push(obj);
                            state.selected = state.objects.length - 1;
                            if (typeof syncRotationUI === 'function') syncRotationUI();
                            render();
                        };
                        img.src = reader.result;
                    };
                    reader.readAsDataURL(file);
                });
                e.target.value = '';
            });

            // å›¾å±‚æ ï¼šæ¸²æŸ“ä¸æ‹–æ‹½æ’åº
            function refreshLayersPanel() {
                const panel = document.getElementById('ws-layers-panel');
                const content = document.getElementById('ws-layers-content');
                if (!panel || !content) return;

                content.innerHTML = '';
                state.objects.forEach((o, idx) => {
                    const item = document.createElement('div');
                    item.className = 'ws-layer-item' + (idx === state.selected ? ' selected' : '');
                    item.setAttribute('draggable', 'true');
                    item.dataset.index = String(idx);

                    const type = document.createElement('span');
                    type.className = 'ws-layer-type';
                    type.textContent = o.type === 'image' ? 'ğŸ–¼ï¸' : 'ğŸŸ©';

                    const label = document.createElement('span');
                    label.className = 'ws-layer-label';
                    label.textContent = o.label || (o.type === 'image' ? 'Image' : 'Mask');

                    const handle = document.createElement('span');
                    handle.className = 'ws-layer-handle';
                    handle.textContent = 'â‰¡';

                    // é™æ€åºå·æ ‡ç­¾ï¼šImage N / Mask Nï¼ˆå›ºå®šï¼Œä¸éšé‡æ’æ”¹å˜ï¼Œä¸å¯ç¼–è¾‘ï¼‰
                    const staticName = document.createElement('span');
                    staticName.className = 'ws-layer-label';
                    staticName.textContent = o.type === 'image'
                        ? (o.seqName || o.label || 'Image')
                        : (o.seqName || 'Mask');

                    item.appendChild(type);
                    item.appendChild(staticName);

                    // ç»¿å¹•ï¼šæä¾›è‡ªå®šä¹‰æ ‡ç­¾ä¸åˆ é™¤æŒ‰é’®ï¼›å›¾ç‰‡ï¼šä»…æä¾›åˆ é™¤æŒ‰é’®
                    if (o.type === 'mask') {
                        const nameInput = document.createElement('input');
                        nameInput.type = 'text';
                        nameInput.placeholder = 'æ ‡ç­¾å';
                        nameInput.value = o.label || '';
                        nameInput.style.flex = '1';
                        nameInput.style.minWidth = '120px';

                        const delBtn = document.createElement('button');
                        delBtn.type = 'button';
                        delBtn.textContent = 'ğŸ—‘ï¸';
                        delBtn.title = 'åˆ é™¤æ­¤ç»¿å¹•';

                        // é˜»æ­¢è¾“å…¥ä¸æŒ‰é’®å†’æ³¡ï¼Œé¿å…è¯¯é€‰ä¸­æˆ–æ‹–æ‹½
                        ['click','mousedown','mouseup','dblclick','keydown','keyup','input'].forEach(ev => {
                            nameInput.addEventListener(ev, e => e.stopPropagation());
                        });
                        ['click','mousedown','mouseup','dblclick','keydown','keyup'].forEach(ev => {
                            delBtn.addEventListener(ev, e => e.stopPropagation());
                        });

                        // èšç„¦æ—¶é”å®šï¼Œé¿å… render é‡å»ºå¯¼è‡´è¾“å…¥å¤±ç„¦ï¼›å¤±ç„¦åå†è§¦å‘ä¸€æ¬¡å®‰å…¨æ¸²æŸ“
                        nameInput.addEventListener('focus', () => { __skipLayersRefresh = true; });
                        nameInput.addEventListener('blur', () => { __skipLayersRefresh = false; render(); });

                        // è¾“å…¥è”åŠ¨è‡ªå®šä¹‰æ ‡ç­¾ï¼ˆè¾“å…¥è¿‡ç¨‹ä¸­è·³è¿‡å›¾å±‚æ åˆ·æ–°ï¼Œä¿æŒç„¦ç‚¹ä¸å…‰æ ‡ï¼‰
                        nameInput.addEventListener('input', () => {
                            o.label = nameInput.value;
                            __skipLayersRefresh = true;
                            render();
                        });

                        // åˆ é™¤ç»¿å¹•å¯¹è±¡
                        delBtn.addEventListener('click', () => {
                            const removeAt = state.objects.indexOf(o);
                            if (removeAt >= 0) {
                                // é‡Šæ”¾ç¼–å·
                                if (typeof o.seqId === 'number') releaseMaskSeq(o.seqId);
                                state.objects.splice(removeAt, 1);
                                if (state.selected >= state.objects.length) {
                                    state.selected = state.objects.length - 1;
                                }
                                render();
                            }
                        });

                        item.appendChild(nameInput);

                        // ç‹¬ç«‹å¼€å…³ï¼šæ˜¯å¦æ˜¾ç¤ºè¯¥é®ç½©çš„æ–‡æ¡ˆï¼ˆä¸å…¨å±€æ€»å¼€å…³å…±åŒç”Ÿæ•ˆï¼‰
                        const showWrap = document.createElement('label');
                        showWrap.style.display = 'flex';
                        showWrap.style.alignItems = 'center';
                        showWrap.style.gap = '6px';
                        showWrap.title = 'æ˜¾ç¤ºé®ç½©æ–‡æ¡ˆ';

                        const showCb = document.createElement('input');
                        showCb.type = 'checkbox';
                        showCb.checked = (o.showText !== false);

                        const showTxt = document.createElement('span');
                        showTxt.textContent = 'æ–‡æ¡ˆ';

                        // é˜»æ­¢å†’æ³¡ï¼Œé¿å…å½±å“é€‰ä¸­/æ‹–æ‹½
                        ['click','mousedown','mouseup','dblclick','keydown','keyup','change'].forEach(ev => {
                            showCb.addEventListener(ev, e => e.stopPropagation());
                            showWrap.addEventListener(ev, e => e.stopPropagation());
                        });

                        showCb.addEventListener('change', () => {
                            o.showText = showCb.checked;
                            render();
                        });

                        showWrap.appendChild(showCb);
                        showWrap.appendChild(showTxt);
                        item.appendChild(showWrap);

                        item.appendChild(delBtn);
                    } else if (o.type === 'image') {
                        // ä¸ºå›¾ç‰‡æä¾›åˆ é™¤æŒ‰é’®ï¼ˆä¸æä¾›é‡å‘½åï¼‰
                        const delBtn = document.createElement('button');
                        delBtn.type = 'button';
                        delBtn.textContent = 'ğŸ—‘ï¸';
                        delBtn.title = 'åˆ é™¤æ­¤å›¾ç‰‡';

                        ['click','mousedown','mouseup','dblclick','keydown','keyup'].forEach(ev => {
                            delBtn.addEventListener(ev, e => e.stopPropagation());
                        });

                        delBtn.addEventListener('click', () => {
                            const removeAt = state.objects.indexOf(o);
                            if (removeAt >= 0) {
                                // é‡Šæ”¾ç¼–å·
                                if (typeof o.seqId === 'number') releaseImageSeq(o.seqId);
                                state.objects.splice(removeAt, 1);
                                if (state.selected >= state.objects.length) {
                                    state.selected = state.objects.length - 1;
                                }
                                if (typeof syncRotationUI === 'function') syncRotationUI();
                                render();
                            }
                        });
                        
                        item.appendChild(delBtn);
                    }
                    
                    item.appendChild(handle);

                    // ç‚¹å‡»è”åŠ¨é€‰ä¸­
                    item.addEventListener('click', () => {
                        state.selected = idx;
                        if (typeof syncRotationUI === 'function') syncRotationUI();
                        render();
                    });

                    // æ‹–æ‹½æ’åº
                    item.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', String(idx));
                        item.classList.add('dragging');
                    });
                    item.addEventListener('dragend', () => {
                        item.classList.remove('dragging');
                    });
                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                    });
                    item.addEventListener('drop', (e) => {
                        e.preventDefault();
                        const src = parseInt(e.dataTransfer.getData('text/plain'), 10);
                        const dst = parseInt(item.dataset.index, 10);
                        if (isNaN(src) || isNaN(dst) || src === dst) return;
                        const moved = state.objects.splice(src, 1)[0];
                        const insertAt = src < dst ? dst - 1 : dst;
                        state.objects.splice(insertAt, 0, moved);
                        state.selected = insertAt;
                        render();
                    });

                    content.appendChild(item);
                });
            }

            // æ·»åŠ ç»¿å¹•ï¼ˆä¸é”å®šå®½é«˜æ¯”ï¼‰
            function refreshMaskList() {
                const list = document.getElementById('ws-mask-list');
                const masks = state.objects.map((o, idx) => ({ o, idx })).filter(t => t.o.type === 'mask');
                list.innerHTML = '';
                masks.forEach(({ o, idx }, i) => {
                    const row = document.createElement('div');
                    row.className = 'ws-mask-item';
                    row.innerHTML = `
            <span style="min-width:48px;color:#333;">ç»¿å¹•${i + 1}</span>
            <input type="text" value="${o.label || ''}" placeholder="æ ‡ç­¾">
            <button type="button" class="ws-mask-del" title="åˆ é™¤">ğŸ—‘ï¸</button>
        `;
                    const input = row.querySelector('input');
                    input.addEventListener('input', () => { o.label = input.value; render(); });

                    // åˆ é™¤æŒ‰é’®ï¼šåˆ é™¤å¯¹åº”ç»¿å¹•ï¼Œä¸å½±å“å…¶ä»–å¯¹è±¡ï¼›æ›´æ–°é€‰ä¸­æ€ã€åˆ—è¡¨ä¸ç”»å¸ƒ
                    const delBtn = row.querySelector('.ws-mask-del');
                    delBtn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        // é‡Šæ”¾ç¼–å·
                        if (typeof o.seqId === 'number') releaseMaskSeq(o.seqId);
                        state.objects.splice(idx, 1);
                        if (state.selected >= state.objects.length) {
                            state.selected = state.objects.length - 1;
                        }
                        refreshMaskList();
                        render();
                    });
                    row.addEventListener('click', () => { state.selected = idx; render(); });
                    list.appendChild(row);
                });
            }

            document.getElementById('ws-add-mask').addEventListener('click', () => {
                const [rw, rh] = __ratioPairOrig(); // ä½¿ç”¨ä¸Šæ–¹é€‰æ‹©æ¯”ä¾‹ä¸æ–¹å‘ï¼Œä¸å—å·¥ä½œåŒºè¦†ç›–å½±å“
                const maxW = state.cssW * 0.5;
                const maxH = state.cssH * 0.5;
                let w = maxW;
                let h = (w * rh) / rw;
                if (h > maxH) {
                    h = maxH;
                    w = (h * rw) / rh;
                }
                // åˆ†é… Mask åºå·ï¼ˆå¾ªç¯æ±  1..15ï¼‰ï¼Œä¸è¶³åˆ™æç¤º
                const seq = allocateMaskSeq();
                if (seq == null) { alert('æ— æ³•æ·»åŠ ç»¿å¹•ï¼šå·²è¾¾åˆ° 15 ä¸ªä¸Šé™'); return; }
                const obj = {
                    type: 'mask',
                    x: (state.cssW - w) / 2,
                    y: (state.cssH - h) / 2,
                    w, h,
                    // è‡ªå®šä¹‰æ ‡ç­¾ç‹¬ç«‹ï¼Œé»˜è®¤ç©ºï¼›å·¥ä½œåŒºæ˜¾ç¤ºæ­¤æ ‡ç­¾ï¼›å›¾å±‚æ æ˜¾ç¤ºå›ºå®šåºå·åœ¨ staticName
                    label: '',
                    showText: true,
                    // å›ºå®šåºå·åï¼ˆä¸å˜æ›´ã€ä¸å—é‡æ’å½±å“ï¼‰
                    seqId: seq,
                    seqName: `Mask ${seq}`
                };
                state.objects.push(obj);
                state.selected = state.objects.length - 1;
                refreshMaskList();
                render();
            });

            // å¯¼å‡ºå·¥ä½œç©ºé—´ä¸ºå›¾ç‰‡ï¼ˆPNGï¼‰
            window.__exportWorkspacePNG = function (scale = 1) {
                const s = Math.max(1, Math.floor(scale));
                const off = document.createElement('canvas');
                const w = Math.round(state.cssW * s);
                const h = Math.round(state.cssH * s);
                off.width = w; off.height = h;
                const c = off.getContext('2d');

                // ä»¥ CSS åæ ‡ç³»ç»˜åˆ¶ï¼Œæ”¾å¤§ s å€è¾“å‡º
                c.setTransform(s, 0, 0, s, 0, 0);

                // ç™½è‰²èƒŒæ™¯
                c.fillStyle = '#ffffff';
                c.fillRect(0, 0, state.cssW, state.cssH);

                // ç»˜åˆ¶å¯¹è±¡
                state.objects.forEach(obj => {
                    if (obj.type === 'image') {
                        if (obj.img) {
                            c.save();
                            const cx = obj.x + obj.w / 2;
                            const cy = obj.y + obj.h / 2;
                            const rot = obj.rotation || 0;
                            const sX = obj.flipH ? -1 : 1;
                            const sY = obj.flipV ? -1 : 1;
                            c.translate(cx, cy);
                            c.scale(sX, sY);
                            if (rot) c.rotate(rot);
                            c.drawImage(obj.img, -obj.w / 2, -obj.h / 2, obj.w, obj.h);
                            c.restore();
                        }
                    } else if (obj.type === 'mask') {
                        // ç»¿å¹•ä¸æè¾¹
                        c.fillStyle = '#00B140';
                        c.fillRect(obj.x, obj.y, obj.w, obj.h);
                        c.strokeStyle = '#00D4AA';
                        c.lineWidth = 2;
                        c.strokeRect(obj.x, obj.y, obj.w, obj.h);

                        if (state.showTexts && (obj.showText !== false)) {
                            // å‚è€ƒæ–œçº¿
                            c.strokeStyle = '#00D4AA';
                            c.lineWidth = 2;
                            c.beginPath();
                            c.moveTo(obj.x + obj.w, obj.y);
                            c.lineTo(obj.x, obj.y + obj.h);
                            c.stroke();
                            // æ ‡ç­¾ï¼šå·¦ä¸Šè§’
                            c.fillStyle = '#00D4AA';
                            c.font = 'bold 14px Arial';
                            c.textBaseline = 'top';
                            c.textAlign = 'start';
                            c.fillText(obj.label || 'Mask', obj.x + 6, obj.y + 6);

                            // ä¸‰è¡Œæ–‡æ¡ˆï¼ˆå¯¼å‡ºåŒæ ·è‡ªé€‚åº”ï¼‰
                            const minSide = Math.min(obj.w, obj.h);
                            const normW = (obj.w / minSide).toFixed(1);
                            const normH = (obj.h / minSide).toFixed(1);
                            const aspectText = `${normW}:${normH}`;

                            const p1 = 'Green screen - Update the input image by replacing the green screen according to the description provided on it.';
                            const p2 = `The aspect ratio of this image is ${aspectText}`;
                            const p3 = 'Do not change the input aspect ratio.';

                            const safeTop = obj.y + 6 + 14 + 8;
                            const safeBottom = obj.y + obj.h - 8;
                            const boxY = safeTop;
                            const boxH = Math.max(10, safeBottom - safeTop);
                            const boxX = obj.x;
                            const boxW = obj.w;

                            function wrapText(context, text, maxWidth) {
                                const words = text.split(' ');
                                const lines = [];
                                let line = '';
                                for (let n = 0; n < words.length; n++) {
                                    const testLine = line ? line + ' ' + words[n] : words[n];
                                    const metrics = context.measureText(testLine);
                                    if (metrics.width > maxWidth && line) {
                                        lines.push(line);
                                        line = words[n];
                                    } else {
                                        line = testLine;
                                    }
                                }
                                if (line) lines.push(line);
                                return lines;
                            }

                            let fitFS = Math.min(obj.w, obj.h) / 12;
                            let lines = [];
                            let lineHeightLocal = 0;

                            for (let i = 0; i < 10; i++) {
                                c.save();
                                const paddingX = fitFS * 0.4;
                                const paddingY = fitFS * 0.3;
                                const maxTextWidth = Math.max(10, boxW - 2 * paddingX - 8);

                                c.font = `bold ${fitFS}px Arial`;
                                const w1 = wrapText(c, p1, maxTextWidth);
                                const w2 = wrapText(c, p2, maxTextWidth);
                                const w3 = wrapText(c, p3, maxTextWidth);
                                c.restore();

                                lines = [...w1, '', '', ...w2, '', '', ...w3];
                                lineHeightLocal = fitFS * 1.2;

                                const nonEmpty = lines.filter(Boolean).length;
                                const totalSpan = (lines.length - 1) * lineHeightLocal + nonEmpty * paddingY;

                                if (totalSpan <= boxH) break;

                                const ratio = Math.max(0.5, boxH / (totalSpan + 0.0001));
                                fitFS = Math.max(6, fitFS * ratio * 0.98);
                            }

                            const paddingY = fitFS * 0.3;
                            const nonEmpty = lines.filter(Boolean).length;
                            const totalSpan = (lines.length - 1) * lineHeightLocal + nonEmpty * paddingY;
                            // å°†èµ·å§‹ Y é’³åˆ¶ï¼Œä¿è¯é¦–è¡ŒèƒŒæ™¯çŸ©å½¢é¡¶éƒ¨ä¸è¶Šè¿‡æ ‡ç­¾å®‰å…¨åŒº
                            let startY = Math.max(
                                boxY + lineHeightLocal / 2 + paddingY / 2,
                                boxY + (boxH - totalSpan) / 2
                            );

                            // è£å‰ªåˆ°æ–‡æœ¬å¯ç”¨åŒºåŸŸï¼Œå¯¼å‡ºç»“æœä¸€è‡´
                            c.save();
                            c.beginPath();
                            c.rect(boxX, boxY, boxW, boxH);
                            c.clip();

                            c.font = `bold ${fitFS}px Arial`;
                            c.textAlign = 'center';
                            c.textBaseline = 'middle';
                            lines.forEach((line, i) => {
                                const y = startY + i * lineHeightLocal;
                                if (line) {
                                    const textWidth = c.measureText(line).width;
                                    const paddingX = fitFS * 0.4;
                                    const paddingY = fitFS * 0.3;
                                    c.fillStyle = '#00B140';
                                    c.fillRect(
                                        obj.x + (obj.w - textWidth) / 2 - paddingX,
                                        y - lineHeightLocal / 2 - paddingY / 2,
                                        textWidth + paddingX * 2,
                                        lineHeightLocal + paddingY
                                    );
                                    c.fillStyle = '#00D4AA';
                                    c.fillText(line, obj.x + obj.w / 2, y);
                                }
                            });
                            c.restore();
                        } else {
                            // ä»…æ ‡ç­¾ï¼šå±…ä¸­æ˜¾ç¤ºï¼ˆå¯¼å‡ºï¼‰
                            c.save();
                            c.fillStyle = '#00D4AA';
                            c.font = 'bold 14px Arial';
                            c.textAlign = 'center';
                            c.textBaseline = 'middle';
                            // å¢¨ç»¿è‰²èƒŒæ™¯å—ï¼ˆå¯¼å‡ºåŒæ ·é€‚é…ï¼‰
                            (function () {
                                const label = obj.label || 'Mask';
                                const fs = parseInt(c.font, 10) || 14;
                                const paddingX = Math.max(6, fs * 0.6);
                                const paddingY = Math.max(4, fs * 0.4);
                                const textWidth = c.measureText(label).width;
                                const cx = obj.x + obj.w / 2;
                                const cy = obj.y + obj.h / 2;

                                c.fillStyle = '#00B140';
                                c.fillRect(
                                    cx - textWidth / 2 - paddingX,
                                    cy - fs / 2 - paddingY,
                                    textWidth + paddingX * 2,
                                    fs + paddingY * 2
                                );

                                c.fillStyle = '#00D4AA';
                                c.fillText(label, cx, cy);
                            })();
                            c.restore();
                        }
                    }
                });

                return off.toDataURL('image/png');
            };

            // è·Ÿéšæ¯”ä¾‹/æ–¹å‘ä¸çª—å£å°ºå¯¸å˜åŒ–
            window.addEventListener('resize', () => updateWorkspaceSize());

            // ç”¨å·¥ä½œç©ºé—´é€»è¾‘æ¥ç®¡ generateGreenscreenï¼ˆä¿æŒæç¤ºè¯åŒºåŸŸæ˜¾ç¤ºï¼‰
            const __origGen = window.generateGreenscreen;
            window.__workspaceActive = true;
            window.generateGreenscreen = function () {
                if (typeof updatePromptText === 'function') updatePromptText();
                document.getElementById('result-section')?.classList.add('show');
            };

            // åˆå§‹
            window.addEventListener('load', () => {
                updateWorkspaceSize();
                refreshMaskList();
                // åˆå§‹åˆ·æ–°å›¾å±‚æ 
                if (typeof refreshLayersPanel === 'function') refreshLayersPanel();
            });
        })();
    </script>
</body>

</html>